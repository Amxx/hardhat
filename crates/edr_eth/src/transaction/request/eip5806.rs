use std::sync::OnceLock;

use alloy_primitives::keccak256;
use alloy_rlp::{RlpDecodable, RlpEncodable};
use k256::SecretKey;

use crate::{
    access_list::AccessListItem,
    signature::{Signature, SignatureError},
    transaction::{fake_signature::make_fake_signature, Eip5806SignedTransaction },
    utils::envelop_bytes,
    Address, Bytes, B256, U256,
};

#[derive(Clone, Debug, PartialEq, Eq, RlpDecodable, RlpEncodable)]
pub struct Eip5806TransactionRequest {
    // The order of these fields determines encoding order.
    pub chain_id: u64,
    pub nonce: u64,
    pub max_priority_fee_per_gas: U256,
    pub max_fee_per_gas: U256,
    pub gas_limit: u64,
    pub to: Address,
    pub input: Bytes,
    pub access_list: Vec<AccessListItem>,
}

impl Eip5806TransactionRequest {
    /// Computes the hash of the transaction.
    pub fn hash(&self) -> B256 {
        let encoded = alloy_rlp::encode(self);

        keccak256(envelop_bytes(4, &encoded))
    }

    pub fn sign(self, secret_key: &SecretKey) -> Result<Eip5806SignedTransaction, SignatureError> {
        let hash = self.hash();

        let signature = Signature::new(hash, secret_key)?;

        Ok(Eip5806SignedTransaction {
            chain_id: self.chain_id,
            nonce: self.nonce,
            max_priority_fee_per_gas: self.max_priority_fee_per_gas,
            max_fee_per_gas: self.max_fee_per_gas,
            gas_limit: self.gas_limit,
            to: self.to,
            input: self.input,
            access_list: self.access_list.into(),
            odd_y_parity: signature.odd_y_parity(),
            r: signature.r,
            s: signature.s,
            hash: OnceLock::new(),
            is_fake: false,
        })
    }

    pub fn fake_sign(self, sender: &Address) -> Eip5806SignedTransaction {
        let signature = make_fake_signature::<1>(sender);

        Eip5806SignedTransaction {
            chain_id: self.chain_id,
            nonce: self.nonce,
            max_priority_fee_per_gas: self.max_priority_fee_per_gas,
            max_fee_per_gas: self.max_fee_per_gas,
            gas_limit: self.gas_limit,
            to: self.to,
            input: self.input,
            access_list: self.access_list.into(),
            odd_y_parity: signature.odd_y_parity(),
            r: signature.r,
            s: signature.s,
            hash: OnceLock::new(),
            is_fake: true,
        }
    }
}

impl From<&Eip5806SignedTransaction> for Eip5806TransactionRequest {
    fn from(t: &Eip5806SignedTransaction) -> Self {
        Self {
            chain_id: t.chain_id,
            nonce: t.nonce,
            max_priority_fee_per_gas: t.max_priority_fee_per_gas,
            max_fee_per_gas: t.max_fee_per_gas,
            gas_limit: t.gas_limit,
            to: t.to,
            input: t.input.clone(),
            access_list: t.access_list.0.clone(),
        }
    }
}

// TODO: tests
// #[cfg(test)]
// pub(crate) mod tests {
//     use std::str::FromStr;

//     use super::*;
//     use crate::transaction::fake_signature::tests::test_fake_sign_properties;

//     fn dummy_request() -> Eip5806TransactionRequest {
//         let input = hex::decode("1234").unwrap();
//         Eip5806TransactionRequest {
//             chain_id: 1,
//             nonce: 1,
//             max_priority_fee_per_gas: U256::from(2),
//             max_fee_per_gas: U256::from(5),
//             gas_limit: 3,
//             to: Address::from_str("0xc014ba5ec014ba5ec014ba5ec014ba5ec014ba5e").unwrap(),
//             input: Bytes::from(input),
//             access_list: vec![AccessListItem {
//                 address: Address::ZERO,
//                 storage_keys: vec![B256::ZERO, B256::from(U256::from(1))],
//             }],
//         }
//     }

//     TODO: tests
//     #[test]
//     fn test_eip5806_transaction_request_encoding() {
//         // Generated by Hardhat
//         // QUESTION: What is considered a valid RLP-encoding? With the prepending type?
//         // or without?
//         let expected =
//             hex::decode("f87b010102050394c014ba5ec014ba5ec014ba5ec014ba5ec014ba5e04821234f85bf859940000000000000000000000000000000000000000f842a00000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000001")
//                 .unwrap();

//         let request = dummy_request();

//         let encoded = alloy_rlp::encode(&request);
//         assert_eq!(expected, encoded);
//     }

//     #[test]
//     fn test_eip5806_transaction_request_hash() {
//         // Generated by hardhat
//         let expected = B256::from_slice(
//             &hex::decode("1d21c520c93f0f8e07c2466361b22a8bb9906cdbf4670e53a701c075bbe69ecf")
//                 .unwrap(),
//         );

//         let request = dummy_request();
//         assert_eq!(expected, request.hash());
//     }

//     test_fake_sign_properties!();

//     #[test]
//     fn test_fake_sign_test_vector() -> anyhow::Result<()> {
//         let transaction = Eip5806TransactionRequest {
//             chain_id: 123,
//             nonce: 0,
//             max_priority_fee_per_gas: U256::from(2),
//             max_fee_per_gas: U256::from(12),
//             gas_limit: 30_000,
//             to: Address::from_str("0xb5bc06d4548a3ac17d72b372ae1e416bf65b8ead".unwrap(),
//             input: Bytes::default(),
//             access_list: vec![],
//         };

//         let fake_sender: Address = "0xa5bc06d4548a3ac17d72b372ae1e416bf65b8ead".parse()?;

//         let signed = transaction.fake_sign(&fake_sender);

//         // Generated by Hardhat
//         let expected_hash: B256 =
//             "ee788ad79d536e2e5146e26b3be0bd12ee4de921c22b3295de3ee16395a015e0".parse()?;
//         assert_eq!(signed.hash(), &expected_hash);

//         Ok(())
//     }
// }
